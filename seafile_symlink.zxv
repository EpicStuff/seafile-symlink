#================================================================
# HEADER
#================================================================
#% USAGE
#+    ${SCRIPT_NAME} [preset ...] 
#%
#% SYNOPSIS
#%    Saves symlinks to a syncable format and restores them from there.
#%
#% DESCRIPTION
#%    Has the ability to save symlink date via placeholder files, or via
#%    `seafile-symlink.txt` in library root. Create custom taml files in
#%    the `preset` directory. Tell the script which taml file to use via
#%    the `preset` param.
#%
#%    Meant to address https://github.com/haiwen/seafile/issues/288
#%
#% OPTIONS
#%    [preset ...]      Specifies which one or more taml config file to use
#%
#% EXAMPLES
#%    ${SCRIPT_NAME} default              # loads ./presets/default.taml
#%    ${SCRIPT_NAME} default.taml         # loads ${pwd}/default.taml
#%    ${SCRIPT_NAME} ~/foo/default.taml   # accepts absolute paths
#%    ${SCRIPT_NAME} library1 library2    # multiple presets at once
#%
#================================================================
#- IMPLEMENTATION
#-    version         1.0
#-    author          Illya Moskvin <ivmoskvin@gmail.com>, EpicStuff
#-    created         2025-02-18
#-    license         GNU JUSTIFIED
#================================================================
# END_OF_HEADER
#================================================================



#================================================================
# Initialization
#================================================================
import std/[strformat, os, strutils, re, symlinks, sequtils]
import pkg/[yanyl]

type config_template = object  #:
	library_path: string
	seafile_path: string
	storage_method: string
	placeholder_ext: string
	db_file: string;
derive_yaml config_template

# get the current directory
var cwd = get_current_dir()
# Change path to where the current script is located, We will need this for resolving relative paths to config files
let app_dir = get_app_dir()
app_dir.set_current_dir()
# Create presets folder (does nothing if it already exists)
create_dir('presets')

# variables ("predecleration")
var file: File
var preset: string



#================================================================
# Function definitions
#================================================================
# Convert potentially Windows path to Unix
proc log(tag: string, msg: string) =
	let color = case tag
		of 'dbg.': '\x1b[38;5;245m'
		of 'info': '\x1b[0m'
		of 'warn': '\x1b[33m'
		of 'err.': '\x1b[31m'
		else: '\x1b[0m'

	echo &'[{color}{tag}\x1b[0m] {msg}';
const debug = 'dbg.'
const info = 'info'
const warn = 'warn'
const err = 'err.'

proc get_localized_path(p: string): string =
	var path = p.normalized_path()
	# Convert Windows drive to POSIX (C: -> /C)
	path = path.replace(re'^([A-Za-z]):', r'/\1')
	# Convert backslashes to forward slashes
	path = path.replace('\\', '/')
	# Ensure ambiguous paths are explicitly relative
	if not (path.starts_with('/') or path.starts_with('.')):
		path = './' & path;
	return path;



#================================================================
# Config loading and validation
#================================================================
# Load the preset name from the argument
let presets = command_line_params()
# Ensure a preset name was passed
if presets.len == 0:
	quit 'Usage: ./seafile_symlink [preset_name]', 1;


# loop though each preset given
for p in presets:
	# if preset doesn't end with .taml, look relative to presets folder
	if not p.ends_with('.taml'):
		preset = p.add_file_ext('.taml').absolute_path(app_dir / 'presets');
	# else look relative to the current directory
	else:
		preset = p.absolute_path(cwd);

	# Ensure the specified config exists
	if not preset.file_exists():
		quit &'Config not found: {preset.absolute_path}', 1;
	# load config for preset
	var config = of_yaml_str(preset.read_file(), config_template)  # TODO: handle invalid taml files

	# Ensure that LibraryPath exists
	if not config.library_path.dir_exists():
		quit &'Cannot resolve library_path to a directory: {config.library_path}', 1;
	# Ensure that seafile_path exists
	config.seafile_path = config.seafile_path.absolute_path(config.library_path)
	if not config.seafile_path.dir_exists():
		quit &'Cannot resolve seafile_path to a directory: {config.library_path}', 1;
	# Ensure the storage method is valid
	if config.storage_method != 'placeholder' and config.storage_method != 'database':
		quit &'Invalid storage_method: {config.storage_method}', 1;
	# Ensure PlaceholderExt starts with a period
	if not config.placeholder_ext.starts_with('.'):
		config.placeholder_ext = '.' & config.placeholder_ext;
	
	# Output some config feedback to user
	info.log(&'Processing library_path: {config.library_path.absolute_path()}')
	info.log(&'Using storage_method: {config.storage_method}')



	#================================================================
	# Data gathering
	#================================================================
	# Enter the LibraryPath. We'll be resolving all paths from here onward.
	config.library_path.set_current_dir()

	# We'll append data in database format to here, then process it later.
	var data_raw: seq[string] = @[]

	# Gather data from actual symlinks
	for path in walk_dir_rec('.', yieldFilter = {pc_link_to_file, pc_link_to_dir}):
		# Read the destination the symlink points to
		data_raw.add(&'{path} >>> {path.expandSymlink.unixToNativePath}');

	# Gather data from symlink placeholders
	for placeholder_path in walk_dir_rec('.', yield_filter = {pcFile}):
		if placeholder_path.ends_with(config.placeholder_ext):
			let link_path = placeholder_path.change_file_ext('')  # Strip the extension
			let dest_path = placeholder_path.read_file().strip()  # Read and strip newline

			data_raw.add(&'{link_path} >>> {dest_path}');;

	# Gather data from symlink database
	if config.db_file.file_exists():
		for line in config.db_file.lines():
			let datum = line.strip()
			if ' >>> ' in datum:
				let parts = datum.split(' >>> ', 1)
				if parts.len == 2:
					let link_path = parts[0].get_localized_path()
					let dest_path = parts[1].get_localized_path()
					data_raw.add(&'{link_path} >>> {dest_path}');
				else:
					log(warn, '{config.db_file}: unable to split line into two parts');;
			else:
				log(warn, '{config.db_file}: missing ` >>> ` delimiter');;;

	# Ensure the array is unique
	data_raw = data_raw.deduplicate()



#================================================================
# Writing files
#================================================================
	if data_raw.len == 0:
		info.log('No symlink data found. Performing cleanup.');
	else:
		info.log('Symlink data found. Processing...');

	# Reset the contents of the symlink database, or delete it if using placeholders
	if config.storage_method == 'database' and data_raw.len > 0:
		file = config.db_file.open(fmWrite)  # Truncate (clear) the file
		info.log(&'Created database: {config.db_file.absolute_path}');
	elif config.db_file.file_exists():
		config.db_file.remove_file()
		info.log(&'Removed database: {config.db_file.absolute_path}');

	# Remove all placeholder files. We'll recreate them below if needed.
	for path in '.'.walk_dir_rec(yield_filter = {pcFile}):
		if path.ends_with(config.placeholder_ext):
			path.remove_file();;


	for datum in data_raw:
		# Skip blank or invalid lines
		if not (' >>> ' in datum):
			warn.log(&'Skipping invalid line (missing delimiter): {datum}')
			continue;

		# Split datum into link_path and dest_path
		let parts = datum.split(' >>> ')
		if parts.len != 2:
			warn.log(&'Skipping malformed line (expected 2 parts): {datum}')
			continue;
		var link_path = parts[0]
		var dest_path = parts[1]

		if config.seafile_path != '':
			let original_path = dest_path
		
			# Convert symlink destination to absolute path
			if not dest_path.is_absolute():
				dest_path = absolute_path(link_path.parent_dir() / dest_path);
			
			# Convert to relative path if target is inside seafile folder
			if dest_path.is_relative_to(config.seafile_path):
				dest_path = relative_path(dest_path, link_path.parent_dir());

			if original_path != dest_path:
				debug.log(&'Converted target: {original_path} -> {dest_path}');;

		# adds ./ if applicable
		if not (destPath.starts_with('/') or destPath.starts_with('./') or destPath.starts_with('../')):
			destPath = './' & destPath;

		# Create symlink
		if link_path.symlink_exists():
			if not (link_path.expand_symlink() == dest_path):
				info.log(&'Overwriting existing symlink: {link_path}, {link_path.expand_symlink()}  >  {dest_path}');
			link_path.remove_file();
		try:
			create_symlink(dest_path, link_path);
		except OSError as e:
			err.log(&'Failed to create symlink: {link_path}  >  {dest_path} ({e.msg})');

		# Write symlink placeholder
		if config.storage_method == 'placeholder':
			write_file(link_path & config.placeholder_ext, dest_path);

		# Append to symlink database
		if config.storage_method == 'database':
			file.write_line(&'{link_path} >>> {dest_path}');

		debug.log(&'{link_path} >>> {dest_path}');
	file.close();


#================================================================
# Cleanup
#================================================================

# Restore our initial working directory
set_current_dir(cwd)
